<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Neon Glow Trail (mobile-friendly)</title>
<style>
  html, body { margin:0; padding:0; }
  body {
    font: 16px/1.5 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
    background: #0f1115;
    color: #e6e6e6;
  }

  /* Demo content so you can see contrast */
  .content {
    max-width: 64rem;
    margin: 0 auto;
    padding: 2rem 1rem 120svh;
  }
  h1 { font-size: 2rem; margin: 1.5rem 0; }
  p { opacity: .9; }
  .grid {
    display: grid;
    gap: 12px;
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
    margin: 1rem 0 2rem;
  }
  .tile {
    aspect-ratio: 4/3;
    border-radius: 12px;
    overflow: hidden;
    background: center/cover no-repeat;
  }
  .tile:nth-child(1){ background-image:url(https://picsum.photos/800/600?blur=0&random=11); }
  .tile:nth-child(2){ background-image:url(https://picsum.photos/800/600?blur=0&random=12); }
  .tile:nth-child(3){ background-image:url(https://picsum.photos/800/600?blur=0&random=13); }
  .tile:nth-child(4){ background-image:url(https://picsum.photos/800/600?blur=0&random=14); }
  .tile:nth-child(5){ background-image:url(https://picsum.photos/800/600?blur=0&random=15); }
  .tile:nth-child(6){ background-image:url(https://picsum.photos/800/600?blur=0&random=16); }

  /* --------- Neon Trail Overlay --------- */

  /* Absolutely positioned overlay, pinned to viewport via JS translateY */
  .trail-container {
    position: absolute;   /* not fixed -> avoids blend/backdrop quirks */
    top: 0;
    right: 0;
    width: 100px;         /* trail strip width (change as you like) */
    height: 100vh;        /* viewport height */
    pointer-events: none; /* allow clicks through */
    z-index: 9999;        /* above content */
  }

  .trail-svg {
    width: 100%;
    height: 100%;
    display: block;
  }

  /* The path is visible by itself; no blending/backdrop needed */
  #trailPath {
    fill: none;
    stroke: url(#neonStroke);
    stroke-width: 6;              /* core stroke width */
    stroke-linecap: round;
    stroke-linejoin: round;
    /* Extra glow using CSS drop-shadows (GPU-friendly on mobile) */
    filter:
      drop-shadow(0 0 2px rgba(0,255,200,.9))
      drop-shadow(0 0 8px rgba(0,255,200,.7))
      drop-shadow(0 0 18px rgba(0,180,255,.8));
  }

  /* Optional: on very bright content, add a thin dark outline to increase legibility */
  #trailOutline {
    fill: none;
    stroke: rgba(0,0,0,.5);
    stroke-width: 1.5;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  /* Mobile tweak – keep the strip a bit narrower if you want */
  @media (max-width: 768px) {
    .trail-container { width: 80px; right: 10px; }
  }
</style>
</head>
<body>

<!-- Neon trail overlay -->
<div class="trail-container" id="trailContainer" aria-hidden="true">
  <!-- viewBox gives stable coordinates; tall so we can draw long curves -->
  <svg class="trail-svg" id="trailSvg" viewBox="0 0 100 2000" preserveAspectRatio="none">
    <defs>
      <!-- Gradient stroke for the neon core -->
      <linearGradient id="neonStroke" x1="0%" y1="0%" x2="0%" y2="100%">
        <stop offset="0%"   stop-color="#00ffd5"/>
        <stop offset="50%"  stop-color="#00b8ff"/>
        <stop offset="100%" stop-color="#7a5cff"/>
      </linearGradient>
    </defs>
    <!-- Outline below the glow to improve text/background contrast -->
    <path id="trailOutline" d=""></path>
    <!-- Main neon path -->
    <path id="trailPath" d=""></path>
  </svg>
</div>

<!-- Page content -->
<div class="content">
  <h1>Neon Glow Trail</h1>
  <p>Scroll to “draw” the trail on the right. It sits above all content and remains crisp on mobile.</p>
  <div class="grid">
    <div class="tile"></div><div class="tile"></div><div class="tile"></div>
    <div class="tile"></div><div class="tile"></div><div class="tile"></div>
  </div>
  <h1>More Content</h1>
  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus vitae lorem quis arcu accumsan sagittis. Suspendisse potenti.</p>
  <div class="grid">
    <div class="tile"></div><div class="tile"></div><div class="tile"></div>
  </div>
</div>

<script>
/*
  Neon trail:
  - Overlay is absolute, pinned to viewport with translateY(scrollY)
  - Path grows with scroll progress (smooth Bezier)
  - No mix-blend-mode / backdrop-filter, so it’s robust on mobile
*/
(function initNeonTrail() {
  const container = document.getElementById('trailContainer');
  const path = document.getElementById('trailPath');
  const outline = document.getElementById('trailOutline');
  if (!container || !path || !outline) return;

  // Pin overlay to viewport (behaves like fixed, without the drawbacks)
  let pinRAF = 0;
  function pin() {
    container.style.transform = `translateY(${window.scrollY}px)`;
  }
  function onScrollPin() {
    if (pinRAF) return;
    pinRAF = requestAnimationFrame(() => { pinRAF = 0; pin(); });
  }
  window.addEventListener('scroll', onScrollPin, { passive: true });
  window.addEventListener('resize', pin);
  pin();

  // Path generation
  const maxPoints = 160;  // increase for smoother curve
  const vbH = 2000;       // must match viewBox height
  const centerX = 60;     // center of the 100px strip
  const ampMain = 20;     // main horizontal wave amplitude
  const ampJitter = 3;    // small jitter for “ink” feel

  function bezier(points) {
    if (points.length < 2) return '';
    let d = `M ${points[0].x} ${points[0].y}`;
    for (let i = 1; i < points.length; i++) {
      const p0 = points[i - 1];
      const p1 = points[i];
      const p2 = points[i + 1] || p1;
      const t = 0.4; // tension
      const dx = p2.x - p0.x;
      const dy = p2.y - p0.y;
      const cp1x = p0.x + dx * t;
      const cp1y = p0.y + dy * t;
      const cp2x = p1.x - dx * t;
      const cp2y = p1.y - dy * t;
      d += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p1.x} ${p1.y}`;
    }
    return d;
  }

  let raf = 0;
  function updatePath() {
    const denom = document.documentElement.scrollHeight - window.innerHeight;
    const pct = denom > 0 ? window.scrollY / denom : 1;
    const prog = Math.max(0, Math.min(pct, 1));
    const target = Math.max(2, Math.floor(prog * maxPoints));

    const pts = [];
    for (let i = 0; i <= target; i++) {
      const t = i / maxPoints;
      const y = t * vbH;
      const x = centerX + Math.sin(t * Math.PI * 3) * ampMain + Math.sin(t * 14) * ampJitter;
      pts.push({ x, y });
    }

    const d = bezier(pts);
    if (d) {
      outline.setAttribute('d', d);
      path.setAttribute('d', d);
    }
  }

  function onScroll() {
    if (raf) return;
    raf = requestAnimationFrame(() => { raf = 0; updatePath(); });
  }

  window.addEventListener('scroll', onScroll, { passive: true });
  window.addEventListener('resize', updatePath);

  // Initial visible line (so you immediately see something)
  outline.setAttribute('d', `M ${centerX} 0 L ${centerX} 1`);
  path.setAttribute('d', `M ${centerX} 0 L ${centerX} 1`);
  updatePath();
})();
</script>
</body>
</html>
